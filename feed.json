{"title":"Qing的博客","description":"前端博客知识小计","language":"","link":"http://myqilixiang.github.io","pubDate":"Wed, 16 Jan 2019 10:13:14 GMT","lastBuildDate":"Thu, 12 Mar 2020 14:17:59 GMT","generator":"hexo-generator-json-feed","webMaster":"Qilx","items":[{"title":"前端开发中IOC的理解","link":"http://myqilixiang.github.io/2019/01/16/前端开发中IOC的理解/","description":"背景前端应用在不断壮大的过程中，内部模块间的依赖可能也会随之越来越复杂，模块间的 低复用性 导致应用 难以维护，不过我们可以借助计算机领域的一些优秀的编程理念来一定程度上解决这些问题，接下来要讲述的_IoC_ 就是其中之一。 什么是 IOCIoC 的全称叫做 Inversion of Control，可翻译为为「控制反转」 或 「依赖倒置」，它主要包含了三个准则： 1、高层次的模块不应该依赖于低层次的模块，它们都应该依赖于抽象2、抽象不应该依赖于具体实现，具体实现应该依赖于抽象3、面向接口编程 而不要面向实现编程 概念总是抽象的，所以下面将以一个例子来解释上述的概念： 假设需要构建一款应用叫 App，它包含一个路由模块 Router和一个页面监控模块 Track，一开始可能会这么实现： 1234567891011121314151617181920212223242526272829// app.jsimport Router from './modules/Router';import Track from './modules/Track';class App &#123; constructor(options) &#123; this.options = options; this.router = new Router(); this.track = new Track(); this.init(); &#125; init() &#123; window.addEventListener('DOMContentLoaded', () =&gt; &#123; this.router.to('home'); this.track.tracking(); this.options.onReady(); &#125;); &#125;&#125;// index.jsimport App from 'path/to/App';new App(&#123; onReady() &#123; // do something here... &#125;,&#125;); 嗯，看起来没什么问题，但是实际应用中需求是非常多变的，可能需要给路由新增功能（比如实现 history 模式）或者更新配置（启用 history, new Router({ mode: &#39;history&#39; })）。这就不得不在 App 内部去修改这两个模块，这是一个 INNER BREAKING 的操作，而对于之前测试通过了的 App 来说，也必须重新测试。 很明显，这不是一个好的应用结构，高层次的模块 App依赖了两个低层次的模块 Router和 Track，对低层次模块的修改都会影响高层次的模块App。那么如何解决这个问题呢，解决方案就是接下来要讲述的 依赖注入（Dependency Injection）。 依赖注入所谓的依赖注入，简单来说就是把高层模块所依赖的模块通过传参的方式把依赖「注入」到模块内部，上面的代码可以通过依赖注入的方式改造成如下方式： 12345678910111213141516171819202122232425262728293031// app.jsclass App &#123; constructor(options) &#123; this.options = options; this.router = options.router; this.track = options.track; this.init(); &#125; init() &#123; window.addEventListener('DOMContentLoaded', () =&gt; &#123; this.router.to('home'); this.track.tracking(); this.options.onReady(); &#125;); &#125;&#125;// index.jsimport App from 'path/to/App';import Router from './modules/Router';import Track from './modules/Track';new App(&#123; router: new Router(), track: new Track(), onReady() &#123; // do something here... &#125;,&#125;); 可以看到，通过依赖注入解决了上面所说的 INNER BREAKING 的问题，可以直接在 App 外部对各个模块进行修改而不影响内部。 是不是就万事大吉了？理想很丰满，但现实却是很骨感的，没过两天产品就给你提了一个新需求，给 App 添加一个分享模块Share。这样的话又回到了上面所提到的 INNER BREAKING 的问题上：你不得不对App模块进行修改加上一行 this.share = options.share，这明显不是我们所期望的。 虽然 App通过依赖注入的方式在一定程度上解耦了与其他几个模块的依赖关系，但是还不够彻底，其中的 this.router 和 this.track等属性其实都还是对「具体实现」的依赖，明显违背了IoC 思想的准则，那如何进一步抽象App模块呢。 Talk is cheap, show you the code 123456789101112131415161718192021222324252627class App &#123; static modules = []; constructor(options) &#123; this.options = options; this.init(); &#125; init() &#123; window.addEventListener('DOMContentLoaded', () =&gt; &#123; this.initModules(); this.options.onReady(this); &#125;); &#125; initModules() &#123; //调用所有module的init方法 App.modules.map(module =&gt; &#123; modules.init &amp;&amp; typeof module.init === 'function' &amp;&amp; module.init(this); &#125;); &#125; //使用use将模块注入到App的modules数组中 可以传入数组 如果是数组的话采用递归实现 static use(module) &#123; Array.isArray(module) ? module.map(item =&gt; &#123; App.use(item); &#125;) : App.modules.push(module); &#125;&#125; 经过改造后 App 内已经没有「具体实现」了，看不到任何业务代码了，那么如何使用 App 来管理我们的依赖呢： 123456789101112131415161718192021222324252627282930313233343536// modules/Router.jsimport Router from 'path/to/Router'export default &#123; init(app)&#123; app.router=new Router(app.options.router) app.router.to('home') &#125;&#125;// modules/Track.jsimport Track from 'path/to/Track'export default &#123; init(app)&#123; app.track=new Track(app.options.track) app.track.tracking() &#125;&#125;// index.jsimport App from 'path/to/App';import Router from './modules/Router';import Track from './modules/Track';App.use([Router,Track])new App(&#123; router:&#123; mode:'history' &#125;, track:&#123; &#125;, onReady(app)&#123; //app.options &#125;&#125;) 可以发现 App 模块在使用上也非常的方便，通过 App.use() 方法来「注入」依赖，在 ./modules/some-module.js 中按照一定的「约定」去初始化相关配置，比如此时需要新增一个 Share 模块的话，无需到 App 内部去修改内容： 123456789101112131415161718192021// modules/Share.jsimport Share from 'path/to/Share';export default &#123; init(app) &#123; app.share = new Share(); app.setShare = data =&gt; app.share.setShare(data); &#125;,&#125;;// index.jsApp.use(Share);new App(&#123; // ... onReady(app) &#123; app.setShare(&#123; title: 'Hello IoC.', description: 'description here...', // some other data here... &#125;); &#125;,&#125;); 直接在 App外部去use这个 Share模块即可，对模块的注入和配置极为方便。 那么在App 内部到底做了哪些工作呢，首先从 App.use方法说起： 12345678class App &#123; static modules = []; static use(module) &#123; Array.isArray(module) ? module.map(item =&gt; App.use(item)) : App.modules.push(module); &#125;&#125; 可以很清楚的发现，App.use 做了一件非常简单的事情，就是把依赖保存在了 App.modules 属性中，等待后续初始化模块的时候被调用。 接下来我们看一下模块初始化方法 this.initModules() 具体做了什么事情： 12345class App &#123; initModules() &#123; App.modules.map(module =&gt; module.init &amp;&amp; typeof module.init == 'function' &amp;&amp; module.init(this)); &#125;&#125; 可以发现该方法同样做了一件非常简单的事情，就是遍历 App.modules 中所有的模块，判断模块是否包含 init 属性且该属性必须是一个函数，如果判断通过的话，该方法就会去执行模块的 init 方法并把 App 的实例this 传入其中，以便在模块中引用它。 从这个方法中可以看出，要实现一个可以被 App.use()的模块，就必须满足两个「约定」： 储和同步功能，带来前所未有的书写体验。特点概述： 1、模块必须包含 init 属性2、init 必须是一个函数 这其实就是 IoC 思想中对「面向接口编程 而不要面向实现编程」这一准则的很好的体现。App 不关心模块具体实现了什么，只要满足对 接口 init 的「约定」就可以了。 此时回去看 Router 的模块的实现就可以很容易理解为什么要怎么写了： 12345678// modules/Router.jsimport Router from 'path/to/Router';export default &#123; init(app) &#123; app.router = new Router(app.options.router); app.router.to('home'); &#125;&#125;; 总结App模块此时应该称之为「容器」比较合适了，跟业务已经没有任何关系了，它仅仅只是提供了一些方法来辅助管理注入的依赖和控制模块如何执行。· 控制反转（Inversion of Control）是一种「思想」，依赖注入（Dependency Injection）则是这一思想的一种具体「实现方式」，而这里的 App 则是辅助依赖管理的一个「容器」。","pubDate":"Wed, 16 Jan 2019 10:13:14 GMT","guid":"http://myqilixiang.github.io/2019/01/16/前端开发中IOC的理解/","category":""},{"title":"Porxy 实现vue MVVM","link":"http://myqilixiang.github.io/2019/01/02/Porxy-实现vue-MVVM/","description":"hahahhadahsdas","pubDate":"Wed, 02 Jan 2019 02:19:52 GMT","guid":"http://myqilixiang.github.io/2019/01/02/Porxy-实现vue-MVVM/","category":""},{"title":"发布-订阅模式","link":"http://myqilixiang.github.io/2017/08/29/JavaScript中的发布-订阅模式/","description":"发布 — 订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在 JavaScript开发中，我们一般用事件模型来替代传统的发布 — 订阅模式。 现实中的发布 － 订阅模式不论是在程序世界里还是现实生活中，发布 — 订阅模式的应用都非常之广泛。我们先看一个现实中的例子。小明最近看上了一套房子，到了售楼处之后才被告知，该楼盘的房子早已售罄。好在售楼MM告诉小明，不久后还有一些尾盘推出，开发商正在办理相关手续，手续办好后便可以购买。但到底是什么时候，目前还没有人能够知道。于是小明记下了售楼处的电话，以后每天都会打电话过去询问是不是已经到了购买时间。除了小明，还有小红、小强、小龙也会每天向售楼处咨询这个问题。一个星期过后，售楼 MM 决定辞职，因为厌倦了每天回答 1000个相同内容的电话。当然现实中没有这么笨的销售公司，实际上故事是这样的：小明离开之前，把电话号码留在了售楼处。售楼 MM 答应他，新楼盘一推出就马上发信息通知小明。小红、小强和小龙也是一样，他们的电话号码都被记在售楼处的花名册上，新楼盘推出的时候，售楼 MM会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们。 发布 － 订阅模式的作用在刚刚的例子中，发送短信通知就是一个典型的发布 — 订阅模式，小明、小红等购买者都是订阅者，他们订阅了房子开售的消息。售楼处作为发布者，会在合适的时候遍历花名册上的电话号码，依次给购房者发布消息。可以发现，在这个例子中使用发布 — 订阅模式有着显而易见的优点 购房者不用再天天给售楼处打电话咨询开售时间，在合适的时间点，售楼处作为发布者会通知这些消息订阅者。 购房者和售楼处之间不再强耦合在一起，当有新的购房者出现时，他只需把手机号码留在售楼处，售楼处不关心购房者的任何情况，不管购房者是男是女还是一只猴子。 而售楼处的任何变动也不会影响购买者，比如售楼 MM 离职，售楼处从一楼搬到二楼，这些改变都跟购房者无关，只要售楼处记得发短信这件事情。 第一点说明发布 — 订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，我们可以订阅 ajax请求的 error 、 succ 等事件。 或者如果想在动画的每一帧完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中使用发布 — 订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。第二点说明发布 — 订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布 — 订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。 DOM 事件实际上，只要我们曾经在 DOM 节点上面绑定过事件函数，那我们就曾经使用过发布 — 订阅模式，来看看下面这两句简单的代码发生了什么事情： 1234document.body.addEventListener( 'click', function()&#123; alert(2);&#125;, false );document.body.click(); // 模拟用户点击 在这里需要监控用户点击 document.body 的动作，但是我们没办法预知用户将在什么时候点击。所以我们订阅 document.body 上的 click 事件，当 body 节点被点击时， body 节点便会向订阅者发布这个消息。这很像购房的例子，购房者不知道房子什么时候开售，于是他在订阅消息后等待售楼处发布消息。当然我们还可以随意增加或者删除订阅者，增加任何订阅者都不会影响发布者代码的编写: 12345678910document.body.addEventListener( 'click', function()&#123; alert(2);&#125;, false );document.body.addEventListener( 'click', function()&#123; alert(3);&#125;, false );document.body.addEventListener( 'click', function()&#123; alert(4);&#125;, false );document.body.click(); // 模拟用户点击 注意，手动触发事件更好的做法是 IE下用 fireEvent ，标准浏览器下用dispatchEvent 实现。 自定义事件除了 DOM 事件，我们还会经常实现一些自定义的事件，这种依靠自定义事件完成的发布 —订阅模式可以用于任何 JavaScript代码中。现在看看如何一步步实现发布 — 订阅模式。 首先要指定好谁充当发布者（比如售楼处）； 然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（售楼处的花名册）； 最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）。 另外，我们还可以往回调函数里填入一些参数，订阅者可以接收这些参数。这是很有必要的，比如售楼处可以在发给订阅者的短信里加上房子的单价、面积、容积率等信息，订阅者接收到这些信息之后可以进行各自的处理： 1234567891011121314151617181920212223242526272829303132333435363738var salesOffices=&#123;&#125;;//定义售楼处salesOffices.clientList=[];//缓存列表，存放订阅者的回调函数salesOffices.listen=function(fn)&#123;//增加订阅者 this.clientList.push(fn);//订阅的消息添加进缓存列表&#125;salesOffices.trigger=function()&#123;//发布消息 for(var i=0,fn;fn=this.clientList[i++];)&#123; fn.apply(this,arguments);//arguments是发布消息时候带的参数 &#125;&#125;//测试salesOffices.listen(function(price,squareMeter)&#123;//小明订阅消息 console.log(\"小明收到消息\") console.log('价格='+price); console.log('面积='+squareMeter);&#125;);salesOffices.listen(function(price,squareMeter)&#123;//小红订阅消息 console.log(\"小红收到消息\") console.log('价格='+price); console.log('面积='+squareMeter);&#125;);salesOffices.trigger(200000,88);salesOffices.trigger(100000,100);//输出结果/*小明收到消息价格=200000面积=88小红收到消息价格=200000面积=88小明收到消息价格=100000面积=100小红收到消息价格=100000面积=100*/ 至此，我们已经实现了一个最简单的发布 — 订阅模式，但这里还存在一些问题。我们看到订阅者接收到了发布者发布的每个消息，虽然小明只想买 88 平方米的房子，但是发布者把 110 平方米的信息也推送给了小明，这对小明来说是不必要的困扰。所以我们有必要增加一个标示 key ，让订阅者只订阅自己感兴趣的消息。改写后的代码如下： 1234567891011121314151617181920212223242526272829303132333435var salesOffices = &#123;&#125;; // 定义售楼处salesOffices.clientList = &#123;&#125;; // 缓存列表，存放订阅者的回调函数salesOffices.listen = function (key, fn) &#123; if (!this.clientList[key]) &#123; // 如果还没有订阅过此类消息，给该类消息创建一个缓存列表 this.clientList[key] = []; &#125; this.clientList[key].push(fn); // 订阅的消息添加进消息缓存列表&#125;;salesOffices.trigger = function () &#123; // 发布消息 var key = Array.prototype.shift.call(arguments), // 取出消息类型 fns = this.clientList[key]; // 取出该消息对应的回调函数集合 if (!fns || fns.length === 0) &#123; // 如果没有订阅该消息，则返回 return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); // (2) // arguments 是发布消息时附送的参数 &#125;&#125;;salesOffices.listen('squareMeter88', function (price) &#123; // 小明订阅 88 平方米房子的消息 console.log(\"小明订阅 88 平方米房子的消息\") console.log('价格= ' + price); // 输出： 2000000&#125;);salesOffices.listen('squareMeter110', function (price) &#123; // 小红订阅 110 平方米房子的消息 console.log(\"小红订阅 110 平方米房子的消息\") console.log('价格= ' + price); // 输出： 3000000&#125;);salesOffices.trigger('squareMeter88', 2000000); // 发布 88 平方米房子的价格salesOffices.trigger('squareMeter110', 3000000); // 发布 110 平方米房子的价格//输出结果/*小明订阅 88 平方米房子的消息价格= 2000000小红订阅 110 平方米房子的消息价格= 3000000*/ 很明显，现在订阅者可以只订阅自己感兴趣的事件了。 发布 － 订阅模式的通用实现现在我们已经看到了如何让售楼处拥有接受订阅和发布事件的功能。假设现在小明又去另一个售楼处买房子，那么这段代码是否必须在另一个售楼处对象上重写一次呢，有没有办法可以让所有对象都拥有发布 — 订阅功能呢？答案显然是有的，JavaScript 作为一门解释执行的语言，给对象动态添加职责是理所当然的事情。所以我们把发布 — 订阅的功能提取出来，放在一个单独的对象内： 12345678910111213141516171819var event = &#123; clientList: [], listen: function (key, fn) &#123; if (!this.clientList[key]) &#123; this.clientList[key] = []; &#125; this.clientList[key].push(fn); // 订阅的消息添加进缓存列表 &#125;, trigger: function () &#123; var key = Array.prototype.shift.call(arguments), // (1); fns = this.clientList[key]; if (!fns || fns.length === 0) &#123; // 如果没有绑定对应的消息 return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); // (2) // arguments 是 trigger 时带上的参数 &#125; &#125;&#125;; 再定义一个 installEvent 函数，这个函数可以给所有的对象都动态安装发布 — 订阅功能： 12345var installEvent = function (obj) &#123; for (var i in event) &#123; obj[i] = event[i]; &#125;&#125;; 再来测试一番，我们给售楼处对象 salesOffices 动态增加发布 — 订阅功能： 12345678910111213141516171819var salesOffices = &#123;&#125;;installEvent(salesOffices);salesOffices.listen('squareMeter88', function (price) &#123; // 小明订阅消息 console.log(\"小明订阅消息\") console.log('价格= ' + price);&#125;);salesOffices.listen('squareMeter100', function (price) &#123; // 小红订阅消息 console.log(\"小红订阅消息\") console.log('价格= ' + price);&#125;);salesOffices.trigger('squareMeter88', 2000000); // 输出：2000000salesOffices.trigger('squareMeter100', 3000000); // 输出：3000000//输出结果/*小明订阅消息价格= 2000000小红订阅消息价格= 3000000*/ 取消订阅的事件有时候，我们也许需要取消订阅事件的功能。比如小明突然不想买房子了，为了避免继续接收到售楼处推送过来的短信，小明需要取消之前订阅的事件。现在我们给 event 对象增加 remove方法： 1234567891011121314151617181920212223242526272829303132event.remove = function (key, fn) &#123; var fns = this.clientList[key]; if (!fns) &#123; // 如果 key 对应的消息没有被人订阅，则直接返回 return false; &#125; if (!fn) &#123; // 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅 fns &amp;&amp; (fns.length = 0); &#125; else &#123; for (var l = fns.length - 1; l &gt;= 0; l--) &#123; // 反向遍历订阅的回调函数列表 var _fn = fns[l]; if (_fn === fn) &#123; fns.splice(l, 1); // 删除订阅者的回调函数 &#125; &#125; &#125;&#125;;var salesOffices = &#123;&#125;;var installEvent = function (obj) &#123; for (var i in event) &#123; obj[i] = event[i]; &#125;&#125;installEvent(salesOffices);salesOffices.listen('squareMeter88', fn1 = function (price) &#123; // 小明订阅消息 console.log('价格= ' + price);&#125;);salesOffices.listen('squareMeter88', fn2 = function (price) &#123; // 小红订阅消息 console.log('价格= ' + price);&#125;);salesOffices.remove('squareMeter88', fn1); // 删除小明的订阅salesOffices.trigger('squareMeter88', 2000000); // 输出：2000000 真实的例子——网站登录通过售楼处的虚拟例子，我们对发布 — 订阅模式的概念和实现都已经熟悉了，那么现在就趁热打铁，看一个真实的项目。假如我们正在开发一个商城网站，网站里有 header头部、nav导航、消息列表、购物车等模块。这几个模块的渲染有一个共同的前提条件，就是必须先用 ajax异步请求获取用户的登录信息。这是很正常的，比如用户的名字和头像要显示在 header模块里，而这两个字段都来自用户登录后返回的信息。至于 ajax请求什么时候能成功返回用户信息，这点我们没有办法确定。现在的情节看起来像极了售楼处的例子，小明不知道什么时候开发商的售楼手续能够成功办下来。但现在还不足以说服我们在此使用发布 — 订阅模式，因为异步的问题通常也可以用回调函数来解决。更重要的一点是，我们不知道除了 header头部、nav导航、消息列表、购物车之外，将来还有哪些模块需要使用这些用户信息。如果它们和用户信息模块产生了强耦合，比如下面这样的形式： 123456login.succ(function(data)&#123; header.setAvatar( data.avatar); // 设置 header 模块的头像 nav.setAvatar( data.avatar ); // 设置导航模块的头像 message.refresh(); // 刷新消息列表 cart.refresh(); // 刷新购物车列表&#125;); 现在登录模块是我们负责编写的，但我们还必须了解 header 模块里设置头像的方法叫setAvatar 、购物车模块里刷新的方法叫 refresh ，这种耦合性会使程序变得僵硬，header 模块不能随意再改变 setAvatar 的方法名，它自身的名字也不能被改为 header1、header2。 这是针对具体实现编程的典型例子，针对具体实现编程是不被赞同的。等到有一天，项目中又新增了一个收货地址管理的模块，这个模块本来是另一个同事所写的，而此时你正在马来西亚度假，但是他却不得不给你打电话：“Hi，登录之后麻烦刷新一下收货地址列表。”于是你又翻开你 3个月前写的登录模块，在最后部分加上这行代码： 1234567login.succ(function( data )&#123; header.setAvatar( data.avatar); nav.setAvatar( data.avatar ); message.refresh(); cart.refresh(); address.refresh(); // 增加这行代码&#125;); 我们就会越来越疲于应付这些突如其来的业务要求，要么跳槽了事，要么必须来重构这些代码。用发布 — 订阅模式重写之后，对用户信息感兴趣的业务模块将自行订阅登录成功的消息事件。当登录成功时，登录模块只需要发布登录成功的消息，而业务方接受到消息之后，就会开始进行各自的业务处理，登录模块并不关心业务方究竟要做什么，也不想去了解它们的内部细节。改善后的代码如下： 123$.ajax( 'http:// xxx.com?login', function(data)&#123; // 登录成功 login.trigger( 'loginSucc', data); // 发布登录成功的消息&#125;); 各模块监听登录成功的消息： 1234567891011121314151617181920var header = (function () &#123; // header 模块 login.listen('loginSucc', function (data) &#123; header.setAvatar(data.avatar); &#125;); return &#123; setAvatar: function (data) &#123; console.log('设置 header 模块的头像'); &#125; &#125;&#125;)();var nav = (function () &#123; // nav 模块 login.listen('loginSucc', function (data) &#123; nav.setAvatar(data.avatar); &#125;); return &#123; setAvatar: function (avatar) &#123; console.log('设置 nav 模块的头像'); &#125; &#125;&#125;)(); 如上所述，我们随时可以把 setAvatar 的方法名改成 setTouxiang 。如果有一天在登录完成之后，又增加一个刷新收货地址列表的行为，那么只要在收货地址模块里加上监听消息的方法即可，而这可以让开发该模块的同事自己完成，你作为登录模块的开发者，永远不用再关心这些行为了。代码如下： 12345678910var address = (function () &#123; // nav 模块 login.listen('loginSucc', function (obj) &#123; address.refresh(obj); &#125;); return &#123; refresh: function (avatar) &#123; console.log('刷新收货地址列表'); &#125; &#125;&#125;)(); 全局的发布 － 订阅对象回想下刚刚实现的发布 — 订阅模式，我们给售楼处对象和登录对象都添加了订阅和发布的功能，这里还存在两个小问题。 我们给每个发布者对象都添加了 listen 和 trigger 方法，以及一个缓存列表 clientList ，这其实是一种资源浪费。 小明跟售楼处对象还是存在一定的耦合性，小明至少要知道售楼处对象的名字是salesOffices ，才能顺利的订阅到事件。见如下代码： 123salesOffices.listen( 'squareMeter100', function( price )&#123; // 小明订阅消息 console.log( '价格= ' + price );&#125;); 如果小明还关心 300平方米的房子，而这套房子的卖家是 salesOffices2 ，这意味着小明要开始订阅 salesOffices2 对象。见如下代码： 123salesOffices2.listen( 'squareMeter300', function( price )&#123; // 小明订阅消息 console.log( '价格= ' + price );&#125;); 其实在现实中，买房子未必要亲自去售楼处，我们只要把订阅的请求交给中介公司，而各大房产公司也只需要通过中介公司来发布房子信息。这样一来，我们不用关心消息是来自哪个房产公司，我们在意的是能否顺利收到消息。当然，为了保证订阅者和发布者能顺利通信，订阅者和发布者都必须知道这个中介公司。同样在程序中，发布 — 订阅模式可以用一个全局的 Event对象来实现，订阅者不需要了解消息来自哪个发布者，发布者也不知道消息会推送给哪些订阅者， Event 作为一个类似“中介者”的角色，把订阅者和发布者联系起来。见如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667var Event = (function () &#123; var clientList = &#123;&#125;, listen, trigger, remove; listen = function (key, fn) &#123; if (!clientList[key]) &#123; clientList[key] = []; &#125; clientList[key].push(fn); &#125;; trigger = function () &#123; var key = Array.prototype.shift.call(arguments), fns = clientList[key]; if (!fns || fns.length === 0) &#123; return false; &#125; for (var i = 0, fn; fn = fns[i++];) &#123; fn.apply(this, arguments); &#125; &#125;; remove = function (key, fn) &#123; var fns = clientList[key]; if (!fns) &#123; return false; &#125; if (!fn) &#123; fns &amp;&amp; (fns.length = 0); &#125; else &#123; for (var l = fns.length - 1; l &gt;= 0; l--) &#123; var _fn = fns[l]; if (_fn === fn) &#123; fns.splice(l, 1); &#125; &#125; &#125; &#125;; return &#123; listen: listen, trigger: trigger, remove: remove &#125;&#125;)();Event.listen('squareMeter88', function (price) &#123; // 小红订阅消息 console.log(\"小红订阅消息\") console.log('价格= ' + price); // 输出：'价格=2000000'&#125;);Event.listen('squareMeter88', function (price) &#123; // 小红订阅消息 console.log(\"小ming订阅消息\") console.log('价格= ' + price); // 输出：'价格=2000000'&#125;);Event.listen('squareMeter11', function (price) &#123; // 小红订阅消息 console.log(\"小ming订阅消息\") console.log('价格= ' + price); // 输出：'价格=2000000'&#125;);Event.trigger('squareMeter88', 2000000); // 售楼处发布消息Event.trigger('squareMeter11', 4000000); // 售楼处发布消息//输出结果/*小红订阅消息价格= 2000000小ming订阅消息价格= 2000000小ming订阅消息价格= 4000000*/ 模块间通信上一节中实现的发布 — 订阅模式的实现，是基于一个全局的 Event 对象，我们利用它可以在两个封装良好的模块中进行通信，这两个模块可以完全不知道对方的存在。就如同有了中介公司之后，我们不再需要知道房子开售的消息来自哪个售楼处。比如现在有两个模块，a模块里面有一个按钮，每次点击按钮之后，b模块里的 div中会显示按钮的总点击次数，我们用全局发布 — 订阅模式完成下面的代码，使得 a 模块和 b 模块可以在保持封装性的前提下进行通信。 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;button id=\"count\"&gt;点我&lt;/button&gt; &lt;div id=\"show\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;script type=\"text/JavaScript\"&gt; var a = (function()&#123; var count = 0; var button = document.getElementById( 'count' ); button.onclick = function()&#123; Event.trigger( 'add', count++ ); &#125; &#125;)(); var b = (function()&#123; var div = document.getElementById( 'show' ); Event.listen( 'add', function( count )&#123; div.innerHTML = count; &#125;); &#125;)();&lt;/script&gt;&lt;/html&gt; 但在这里我们要留意另一个问题，模块之间如果用了太多的全局发布 — 订阅模式来通信，那么模块与模块之间的联系就被隐藏到了背后。我们最终会搞不清楚消息来自哪个模块，或者消息会流向哪些模块，这又会给我们的维护带来一些麻烦，也许某个模块的作用就是暴露一些接口给其他模块调用。 必须先订阅再发布吗我们所了解到的发布 — 订阅模式，都是订阅者必须先订阅一个消息，随后才能接收到发布者发布的消息。如果把顺序反过来，发布者先发布一条消息，而在此之前并没有对象来订阅它，这条消息无疑将消失在宇宙中。在某些情况下，我们需要先将这条消息保存下来，等到有对象来订阅它的时候，再重新把消息发布给订阅者。就如同 QQ中的离线消息一样，离线消息被保存在服务器中，接收人下次登录上线之后，可以重新收到这条消息。这种需求在实际项目中是存在的，比如在之前的商城网站中，获取到用户信息之后才能渲染用户导航模块，而获取用户信息的操作是一个 ajax 异步请求。当 ajax 请求成功返回之后会发布一个事件，在此之前订阅了此事件的用户导航模块可以接收到这些用户信息。但是这只是理想的状况，因为异步的原因，我们不能保证 ajax请求返回的时间，有时候它返回得比较快，而此时用户导航模块的代码还没有加载好（还没有订阅相应事件），特别是在用了一些模块化惰性加载的技术后，这是很可能发生的事情。也许我们还需要一个方案，使得我们的发布 — 订阅对象拥有先发布后订阅的能力。为了满足这个需求，我们要建立一个存放离线事件的堆栈，当事件发布的时候，如果此时还没有订阅者来订阅这个事件，我们暂时把发布事件的动作包裹在一个函数里，这些包装函数将被存入堆栈中，等到终于有对象来订阅此事件的时候，我们将遍历堆栈并且依次执行这些包装函数，也就是重新发布里面的事件。当然离线事件的生命周期只有一次，就像 QQ的未读消息只会被重新阅读一次，所以刚才的操作我们只能进行一次。 全局事件的命名冲突全局的发布 — 订阅对象里只有一个 clinetList 来存放消息名和回调函数，大家都通过它来订阅和发布各种消息，久而久之，难免会出现事件名冲突的情况，所以我们还可以给 Event 对象提供创建命名空间的功能。在提供最终的代码之前，我们来感受一下怎么使用这两个新增的功能。 1234567891011121314/************** 先发布后订阅 ********************/Event.trigger('click', 1);Event.listen('click', function(a) &#123; console.log(a); // 输出：1&#125;);/************** 使用命名空间 ********************/Event.create('namespace1').listen('click', function(a) &#123; console.log(a); // 输出：1&#125;);Event.create('namespace1').trigger('click', 1);Event.create('namespace2').listen('click', function(a) &#123; console.log(a); // 输出：2&#125;);Event.create('namespace2').trigger('click', 2); 具体实现代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123var Event = (function() &#123; var global = this, Event, _default = \"default\"; Event = function() &#123; var _listen, _trigger, _remove, _slice = Array.prototype.slice, _shift = Array.prototype.shift, _unshift = Array.prototype.unshift, namespaceCache = &#123;&#125;, _create, find, each = function(ary, fn) &#123; var ret; for (var i = 0, l = ary.length; i &lt; l; i++) &#123; var n = ary[i]; ret = fn.call(n, i, n); &#125; return ret; &#125;; _listen = function(key, fn, cache) &#123; if (!cache[key]) &#123; cache[key] = []; &#125; cache[key].push(fn); &#125;; _remove = function(key, cache, fn) &#123; if (cache[key]) &#123; if (fn) &#123; for (var i = cache[key].length; i &gt;= 0; i--) &#123; if (cache[key][i] === fn) &#123; cache[key].splice(i, 1); &#125; &#125; &#125; else &#123; cache[key] = []; &#125; &#125; &#125;; _trigger = function() &#123; var cache = _shift.call(arguments), key = _shift.call(arguments), args = arguments, _self = this, ret, stack = cache[key]; if (!stack || !stack.length) &#123; return; &#125; return each(stack, function() &#123; return this.apply(_self, args); &#125;); &#125;; _create = function(namespace) &#123; var namespace = namespace || _default; var cache = &#123;&#125;, offlineStack = [], // 离线事件 ret = &#123; listen: function(key, fn, last) &#123; _listen(key, fn, cache); if (offlineStack === null) &#123; return; &#125; if (last === 'last') &#123; offlineStack.length &amp;&amp; offlineStack.pop()(); &#125; else &#123; each(offlineStack, function() &#123; this(); &#125;); &#125; offlineStack = null; &#125;, one: function(key, fn, last) &#123; _remove(key, cache); this.listen(key, fn, last); &#125;, remove: function(key, fn) &#123; _remove(key, cache, fn); &#125;, trigger: function() &#123; var fn, args, _self = this; _unshift.call(arguments, cache); args = arguments; fn = function() &#123; return _trigger.apply(_self, args); &#125;; if (offlineStack) &#123; return offlineStack.push(fn); &#125; return fn(); &#125; &#125;; return namespace ? (namespaceCache[namespace] ? namespaceCache[namespace] : namespaceCache[namespace] = ret) : ret; &#125;; return &#123; create: _create, one: function(key, fn, last) &#123; var event = this.create(); event.one(key, fn, last); &#125;, remove: function(key, fn) &#123; var event = this.create(); event.remove(key, fn); &#125;, listen: function(key, fn, last) &#123; var event = this.create(); event.listen(key, fn, last); &#125;, trigger: function() &#123; var event = this.create(); event.trigger.apply(this, arguments); &#125; &#125;; &#125;(); return Event;&#125;)(); JavaScript 实现发布 － 订阅模式的便利性这里要提出的是，我们一直讨论的发布 — 订阅模式，跟一些别的语言（比如 Java）中的实现还是有区别的。在 Java中实现一个自己的发布 — 订阅模式，通常会把订阅者对象自身当成引用传入发布者对象中，同时订阅者对象还需提供一个名为诸如 update的方法，供发布者对象在适合的时候调用。而在 JavaScript中，我们用注册回调函数的形式来代替传统的发布 — 订阅模式，显得更加优雅和简单。另外，在 JavaScript中，我们无需去选择使用推模型还是拉模型。推模型是指在事件发生时，发布者一次性把所有更改的状态和数据都推送给订阅者。拉模型不同的地方是，发布者仅仅通知订阅者事件已经发生了，此外发布者要提供一些公开的接口供订阅者来主动拉取数据。拉模型的好处是可以让订阅者“按需获取”，但同时有可能让发布者变成一个“门户大开”的对象，同时增加了代码量和复杂度。刚好在 JavaScript中， arguments 可以很方便地表示参数列表，所以我们一般都会选择推模型，使用 Function.prototype.apply 方法把所有参数都推送给订阅者。 小结本章我们学习了发布 — 订阅模式，也就是常说的观察者模式。发布 — 订阅模式在实际开发中非常有用。发布 — 订阅模式的优点非常明显，一为时间上的解耦，二为对象之间的解耦。它的应用非常广泛，既可以用在异步编程中，也可以帮助我们完成更松耦合的代码编写。发布 — 订阅模式还可以用来帮助实现一些别的设计模式，比如中介者模式。 从架构上来看，无论是 MVC还是 MVVM，都少不了发布 — 订阅模式的参与，而且 JavaScript本身也是一门基于事件驱动的语言。当然，发布 — 订阅模式也不是完全没有缺点。创建订阅者本身要消耗一定的时间和内存，而且当你订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。另外，发布 — 订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个 bug不是件轻松的事情。 End","pubDate":"Tue, 29 Aug 2017 02:48:17 GMT","guid":"http://myqilixiang.github.io/2017/08/29/JavaScript中的发布-订阅模式/","category":"发布-订阅"},{"title":"javascript中this、call和apply","link":"http://myqilixiang.github.io/2017/08/28/javascript中this、call和apply/","description":"在 JavaScript 编程中， this 关键字总是让初学者感到迷惑， Function.prototype.call 和Function.prototype.apply 这两个方法也有着广泛的运用。我们有必要在学习设计模式之前先理解这几个概念。 1.this1.1 this的指向除去不常用的 with 和 eval 的情况，具体到实际应用中， this 的指向大致可以分为以下 4种。 作为对象的方法调用。 作为普通函数调用。 构造器调用。 Function.prototype.call 或 Function.prototype.apply 调用。 1. 作为对象的方法调用当函数作为对象的方法被调用时， this 指向该对象： 12345678var obj = &#123;a: 1,getA: function()&#123;alert ( this === obj ); // 输出：truealert ( this.a ); // 输出: 1&#125;&#125;;obj.getA(); 2. 作为普通函数调用当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的 this 总是指向全局对象。在浏览器的 JavaScript里，这个全局对象是 window 对象。 123456789101112131415window.name = 'globalName';var getName = function()&#123;return this.name;&#125;;console.log( getName() ); // 输出：globalName或者：window.name = 'globalName';var myObject = &#123;name: 'sven',getName: function()&#123;return this.name;&#125;&#125;;var getName = myObject.getName;console.log( getName() ); // globalName 有时候我们会遇到一些困扰，比如在 div 节点的事件函数内部，有一个局部的 callback 方法，callback被作为普通函数调用时， callback 内部的 this 指向了 window ，但我们往往是想让它指向该 div 节点，见如下代码： 123456789101112131415&lt;html&gt; &lt;body&gt; &lt;div id=\"div1\"&gt;我是一个 div&lt;/div&gt; &lt;/body&gt; &lt;script&gt; window.id = 'window'; document.getElementById( 'div1' ).onclick = function()&#123; alert ( this.id ); // 输出：'div1' var callback = function()&#123; alert ( this.id ); // 输出：'window' &#125; callback(); &#125;; &lt;/script&gt;&lt;/html&gt; 此时有一种简单的解决方案，可以用一个变量保存 div 节点的引用： 1234567document.getElementById( 'div1' ).onclick = function()&#123; var that = this; // 保存 div 的引用 var callback = function()&#123; alert ( that.id ); // 输出：'div1' &#125; callback();&#125;; 在 ECMAScript 5的 strict 模式下，这种情况下的 this 已经被规定为不会指向全局对象，而是 undefined ： 12345function func()&#123; \"use strict\" alert ( this ); // 输出：undefined&#125;func(); 3. 构造器调用JavaScript 中没有类，但是可以从构造器中创建对象，同时也提供了 new 运算符，使得构造器看起来更像一个类。除了宿主提供的一些内置函数，大部分 JavaScript函数都可以当作构造器使用。构造器的外表跟普通函数一模一样，它们的区别在于被调用的方式。当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象，见如下代码： 12345var MyClass = function()&#123; this.name = 'sven';&#125;;var obj = new MyClass();alert ( obj.name ); // 输出：sven 但用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this ： 12345678var MyClass = function()&#123; this.name = 'sven'; return &#123; // 显式地返回一个对象 name: 'anne' &#125;&#125;;var obj = new MyClass();alert ( obj.name ); // 输出：anne 如果构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题： 123456var MyClass = function()&#123; this.name = 'sven' return 'anne'; // 返回 string 类型&#125;;var obj = new MyClass();alert ( obj.name ); // 输出：sven 4. Function.prototype.call 或 Function.prototype.apply 调用跟普通的函数调用相比，用 Function.prototype.call 或 Function.prototype.apply 可以动态地改变传入函数的 this ： 1234567891011var obj1 = &#123; name: 'sven', getName: function()&#123; return this.name; &#125;&#125;;var obj2 = &#123; name: 'anne'&#125;;console.log( obj1.getName() ); // 输出: svenconsole.log( obj1.getName.call( obj2 ) ); // 输出：anne call 和 apply 方法能很好地体现 JavaScript的函数式语言特性，在 JavaScript中，几乎每一次编写函数式语言风格的代码，都离不开 call 和 apply 。 1.2 丢失的this这是一个经常遇到的问题，我们先看下面的代码： 123456789var obj = &#123; myName: 'sven', getName: function()&#123; return this.myName; &#125;&#125;;console.log( obj.getName() ); // 输出：'sven'var getName2 = obj.getName;console.log( getName2() ); // 输出：undefined 当调用 obj.getName 时， getName 方法是作为 obj 对象的属性被调用的，根据之前提到的规律，此时的 this 指向 obj 对象，所以 obj.getName() 输出 ‘sven’ 。当用另外一个变量 getName2 来引用 obj.getName ，并且调用 getName2 时，根据之前提到的规律，此时是普通函数调用方式， this是指向全局window的，所以程序的执行结果是 undefined 。再看另一个例子， document.getElementById 这个方法名实在有点过长，我们大概尝试过用一个短的函数来代替它，如同 prototype.js 等一些框架所做过的事情： 1234var getId = function( id )&#123; return document.getElementById( id );&#125;;getId( 'div1' ); 我们也许思考过为什么不能用下面这种更简单的方式： 12var getId = document.getElementById;getId( 'div1' ); 现在不妨花 1分钟时间，让这段代码在浏览器中运行一次： 123456789&lt;html&gt; &lt;body&gt; &lt;div id=\"div1\"&gt;我是一个 div&lt;/div&gt; &lt;/body&gt; &lt;script&gt; var getId = document.getElementById; getId( 'div1' ); &lt;/script&gt;&lt;/html&gt; 在 Chrome、Firefox、IE10 中执行过后就会发现，这段代码抛出了一个异常。这是因为许多引擎的 document.getElementById 方法的内部实现中需要用到 this 。这个 this 本来被期望指向document ，当 getElementById 方法作为 document 对象的属性被调用时，方法内部的 this 确实是指向 document 的。但当用 getId 来引用 document.getElementById 之后，再调用 getId ，此时就成了普通函数调用，函数内部的 this 指向了 window ，而不是原来的 document 。我们可以尝试利用 apply 把 document 当作 this 传入 getId 函数，帮助“修正” this ： 12345678document.getElementById = (function( func )&#123; return function()&#123; return func.apply( document, arguments ); &#125;&#125;)( document.getElementById );var getId = document.getElementById;var div = getId( 'div1' );alert (div.id); // 输出： div1 2.call 和 applyECAMScript 3给 Function 的原型定义了两个方法，它们是 Function.prototype.call 和 Function.prototype.apply 。在实际开发中，特别是在一些函数式风格的代码编写中， call 和 apply 方法尤为有用。 2.1call 和 apply 的区别Function.prototype.call 和 Function.prototype.apply 都是非常常用的方法。它们的作用一模一样，区别仅在于传入参数形式的不同。apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组， apply 方法把这个集合中的元素作为参数传递给被调用的函数： 1234var func = function( a, b, c )&#123; alert ( [ a, b, c ] ); // 输出 [ 1, 2, 3 ]&#125;;func.apply( null, [ 1, 2, 3 ] ); 在这段代码中，参数 1、2、3 被放在数组中一起传入 func 函数，它们分别对应 func 参数列表中的 a 、 b 、 c 。在这段代码中，参数 1、2、3 被放在数组中一起传入 func 函数，它们分别对应 func 参数列表中的 a 、 b 、 c 。 1234var func = function( a, b, c )&#123; alert ( [ a, b, c ] ); // 输出 [ 1, 2, 3 ]&#125;;func.call( null, 1, 2, 3 ); 当调用一个函数时，JavaScript 的解释器并不会计较形参和实参在数量、类型以及顺序上的区别，JavaScript的参数在内部就是用一个数组来表示的。从这个意义上说， apply 比 call 的使用率更高，我们不必关心具体有多少参数被传入函数，只要用 apply 一股脑地推过去就可以了。call 是包装在 apply 上面的一颗语法糖，如果我们明确地知道函数接受多少个参数，而且想一目了然地表达形参和实参的对应关系，那么也可以用 call 来传送参数。当使用 call 或者 apply 的时候，如果我们传入的第一个参数为 null ，函数体内的 this 会指向默认的宿主对象，在浏览器中则是 window ： 1234var func = function( a, b, c )&#123; alert ( this === window ); // 输出 true &#125;;func.apply( null, [ 1, 2, 3 ] ); 但如果是在严格模式下，函数体内的 this 还是为 null ： 12345var func = function( a, b, c )&#123; \"use strict\"; alert ( this === null ); // 输出 true&#125;func.apply( null, [ 1, 2, 3 ] ); 有时候我们使用 call 或者 apply 的目的不在于指定 this 指向，而是另有用途，比如借用其他对象的方法。那么我们可以传入 null 来代替某个具体的对象： 1Math.max.apply( null, [ 1, 2, 5, 3, 4 ] ) // 输出：5 2.2call 和 apply 的用途1.改变 this 指向call 和 apply 最常见的用途是改变函数内部的 this 指向，我们来看个例子： 12345678910111213var obj1 = &#123; name: 'sven'&#125;;var obj2 = &#123; name: 'anne'&#125;;window.name = 'window';var getName = function()&#123; alert ( this.name );&#125;;getName(); // 输出: windowgetName.call( obj1 ); // 输出: svengetName.call( obj2 ); // 输出: anne 当执行 getName.call( obj1 ) 这句代码时， getName 函数体内的 this 就指向 obj1 对象，所以此处的 123var getName = function()&#123; alert ( this.name );&#125;; 实际上相当于: 123var getName = function()&#123; alert ( obj1.name ); // 输出: sven&#125;; 在实际开发中，经常会遇到 this 指向被不经意改变的场景，比如有一个 div 节点， div 节点的 onclick 事件中的 this 本来是指向这个 div 的： 123document.getElementById( 'div1' ).onclick = function()&#123; alert( this.id ); // 输出：div1&#125;; 假如该事件函数中有一个内部函数 func ，在事件内部调用 func 函数时， func 函数体内的 this就指向了 window ，而不是我们预期的 div ，见如下代码： 1234567document.getElementById( 'div1' ).onclick = function()&#123; alert( this.id ); // 输出：div1 var func = function()&#123; alert ( this.id ); // 输出：undefined &#125;func();&#125;; 这时候我们用 call 来修正 func 函数内的 this ，使其依然指向 div ： 123456document.getElementById( 'div1' ).onclick = function()&#123; var func = function()&#123; alert ( this.id ); // 输出：div1 &#125; func.call( this );&#125;; 2. Function.prototype.bind大部分高级浏览器都实现了内置的 Function.prototype.bind ，用来指定函数内部的 this 指向，即使没有原生的 Function.prototype.bind 实现，我们来模拟一个也不是难事，代码如下： 1234567891011121314Function.prototype.bind = function( context )&#123; var self = this; // 保存原函数 return function()&#123; // 返回一个新的函数 return self.apply( context, arguments ); // 执行新的函数的时候，会把之前传入的 context // 当作新函数体内的 this&#125;&#125;;var obj = &#123; name: 'sven'&#125;;var func = function()&#123; alert ( this.name ); // 输出：sven&#125;.bind( obj);func(); 我们通过 Function.prototype.bind 来“包装” func 函数，并且传入一个对象 context 当作参数，这个 context 对象就是我们想修正的 this 对象。在 Function.prototype.bind 的内部实现中，我们先把 func 函数的引用保存起来，然后返回一个新的函数。当我们在将来执行 func 函数时，实际上先执行的是这个刚刚返回的新函数。在新函数内部，self.apply( context, arguments ) 这句代码才是执行原来的 func 函数，并且指定 context对象为 func 函数体内的 this 。这是一个简化版的 Function.prototype.bind 实现，通常我们还会把它实现得稍微复杂一点，使得可以往 func 函数中预先填入一些参数： 123456789101112131415161718Function.prototype.bind = function()&#123; var self = this, // 保存原函数 context = [].shift.call( arguments ), // 需要绑定的 this 上下文 args = [].slice.call( arguments ); // 剩余的参数转成数组 return function()&#123; // 返回一个新的函数 return self.apply( context, [].concat.call( args, [].slice.call( arguments ) ) ); // 执行新的函数的时候，会把之前传入的 context 当作新函数体内的 this // 并且组合两次分别传入的参数，作为新函数的参数 &#125; &#125;; var obj = &#123; name: 'sven'&#125;;var func = function( a, b, c, d )&#123; alert ( this.name ); // 输出：sven alert ( [ a, b, c, d ] ) // 输出：[ 1, 2, 3, 4 ]&#125;.bind( obj, 1, 2 );func( 3, 4 ); 3.借用其他对象的方法我们知道，杜鹃既不会筑巢，也不会孵雏，而是把自己的蛋寄托给云雀等其他鸟类，让它们代为孵化和养育。同样，在 JavaScript中也存在类似的借用现象。借用方法的第一种场景是“借用构造函数”，通过这种技术，可以实现一些类似继承的效果： 1234567891011var A = function( name )&#123; this.name = name;&#125;;var B = function()&#123; A.apply( this, arguments );&#125;;B.prototype.getName = function()&#123; return this.name;&#125;;var b = new B( 'sven' );console.log( b.getName() ); // 输出： 'sven' 借用方法的第二种运用场景跟我们的关系更加密切。函数的参数列表 arguments 是一个类数组对象，虽然它也有“下标”，但它并非真正的数组，所以也不能像数组一样，进行排序操作或者往集合里添加一个新的元素。这种情况下，我们常常会借用 Array.prototype 对象上的方法。比如想往 arguments 中添加一个新的元素，通常会借用Array.prototype.push ： 1234(function()&#123; Array.prototype.push.call( arguments, 3 ); console.log ( arguments ); // 输出[1,2,3]&#125;)( 1, 2 ); 在操作 arguments 的时候，我们经常非常频繁地找 Array.prototype 对象借用方法。想把 arguments 转成真正的数组的时候，可以借用 Array.prototype.slice 方法；想截去arguments 列表中的头一个元素时，又可以借用 Array.prototype.shift 方法。那么这种机制的内部实现原理是什么呢？我们不妨翻开 V8的引擎源码，以 Array.prototype.push 为例，看看 V8引擎中的具体实现： 123456789function ArrayPush() &#123; var n = TO_UINT32( this.length ); // 被 push 的对象的 length var m = %_ArgumentsLength(); // push 的参数个数 for (var i = 0; i &lt; m; i++) &#123; this[ i + n ] = %_Arguments( i ); // 复制元素 (1) &#125; this.length = n + m; // 修正 length 属性的值 (2) return this.length;&#125;; 通过这段代码可以看到， Array.prototype.push 实际上是一个属性复制的过程，把参数按照下标依次添加到被 push 的对象上面，顺便修改了这个对象的 length 属性。至于被修改的对象是谁，到底是数组还是类数组对象，这一点并不重要。由此可以推断，我们可以把“任意”对象传入 Array.prototype.push ： 1234var a = &#123;&#125;;Array.prototype.push.call( a, 'first' );alert ( a.length ); // 输出：1alert ( a[ 0 ] ); // first 这段代码在绝大部分浏览器里都能顺利执行，但由于引擎的内部实现存在差异，如果在低版本的 IE浏览器中执行，必须显式地给对象 a 设置 length 属性： 123var a = &#123; length: 0&#125;; 前面我们之所以把“任意”两字加了双引号，是因为可以借用 Array.prototype.push 方法的对象还要满足以下两个条件，从 ArrayPush 函数的(1)处和(2)处也可以猜到，这个对象至少还要满足： 对象本身要可以存取属性； 对象的 length 属性可读写。对于第一个条件，对象本身存取属性并没有问题，但如果借用 Array.prototype.push 方法的不是一个 object 类型的数据，而是一个 number 类型的数据呢? 我们无法在 number 身上存取其他数据，那么从下面的测试代码可以发现，一个 number 类型的数据不可能借用到 Array.prototype.push 方法： 1234var a = 1;Array.prototype.push.call( a, 'first' );alert ( a.length ); // 输出：undefinedalert ( a[ 0 ] ); // 输出：undefined 对于第二个条件，函数的 length 属性就是一个只读的属性，表示形参的个数，我们尝试把一个函数当作 this 传入 Array.prototype.push ： 1234var func = function()&#123;&#125;;Array.prototype.push.call( func, 'first' );alert ( func.length );// 报错：cannot assign to read only property ‘length’ of function()&#123;&#125; End","pubDate":"Mon, 28 Aug 2017 08:16:59 GMT","guid":"http://myqilixiang.github.io/2017/08/28/javascript中this、call和apply/","category":"this,,call,,apply"},{"title":"git使用总结","link":"http://myqilixiang.github.io/2017/08/24/git使用总结/","description":"一、Git工作流程以上包括一些简单而常用的命令，但是先不关心这些，先来了解下面这4个专有名词。 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 工作区程序员进行开发改动的地方，是你当前看到的，也是最新的。 平常我们开发就是拷贝远程仓库中的一个分支，基于该分支进行开发。在开发过程中就是对工作区的操作。 暂存区.git目录下的index文件, 暂存区会记录git add添加文件的相关信息(文件名、大小、timestamp…)，不保存文件实体, 通过id指向每个文件实体。可以使用git status查看暂存区的状态。暂存区标记了你当前工作区中，哪些内容是被git管理的。 当你完成某个需求或功能后需要提交到远程仓库，那么第一步就是通过git add先提交到暂存区，被git管理。 本地仓库保存了对象被提交 过的各个版本，比起工作区和暂存区的内容，它要更旧一些。git commit后同步index的目录树到本地仓库，方便从下一步通过git push同步本地仓库与远程仓库的同步。 远程仓库远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改，因此它可能与本地仓库同步，也可能不同步，但是它的内容是最旧的。 小结1、任何对象都是在工作区中诞生和被修改；2、任何修改都是从进入index区才开始被版本控制；3、只有把修改提交到本地仓库，该修改才能在仓库中留下痕迹；4、与协作者分享本地的修改，可以把它们push到远程仓库来共享。下面这幅图更加直接阐述了四个区域之间的关系，可能有些命令不太清楚，没关系，下部分会详细介绍。 二、常用Git命令 HEAD在掌握具体命令前，先理解下HEAD。HEAD，它始终指向当前所处分支的最新的提交点。你所处的分支变化了，或者产生了新的提交点，HEAD就会跟着改变。 addadd相关命令很简单，主要实现将工作区修改的内容提交到暂存区，交由git管理。 git add . 添加当前目录的所有文件到暂存区 git add [dir] 添加指定目录到暂存区，包括子目录 git add [file1] 添加指定文件到暂存区 commitcommit相关命令也很简单，主要实现将暂存区的内容提交到本地仓库，并使得当前分支的HEAD向后移动一个提交点。 git commit -m [message] 提交暂存区到本地仓库,message代表说明信息git commit [file1] -m [message] 提交暂存区的指定文件到本地仓库git commit –amend -m [message] 使用一次新的commit，替代上一次提交 branch涉及到协作，自然会涉及到分支，关于分支，大概有展示分支，切换分支，创建分支，删除分支这四种操作。 git branch 列出所有本地分支git branch -r 列出所有远程分支git branch -a 列出所有本地分支和远程分支git branch [branch-name] 新建一个分支，但依然停留在当前分支git checkout -b [branch-name] 新建一个分支，并切换到该分支git branch –track [branch][remote-branch] 新建一个分支，与指定的远程分支建立追踪关系git checkout [branch-name] 切换到指定分支，并更新工作区git branch -d [branch-name] 删除分支git push origin –delete [branch-name] 删除远程分支 关于分支的操作虽然比较多，但都比较简单好记。 ## mergemerge命令把不同的分支合并起来。如上图，在实际开放中，我们可能从master分支中切出一个分支，然后进行开发完成需求，中间经过R3,R4,R5的commit记录，最后开发完成需要合入master中，这便用到了merge。 git fetch [remote] merge之前先拉一下远程仓库最新代码git merge [branch] 合并指定分支到当前分支 一般在merge之后，会出现conflict，需要针对冲突情况，手动解除冲突。主要是因为两个用户修改了同一文件的同一块区域。如下图所示，需要手动解除。 rebaserebase又称为衍合，是合并的另外一种选择。 在开始阶段，我们处于new分支上，执行git rebase dev，那么new分支上新的commit都在master分支上重演一遍，最后checkout切换回到new分支。这一点与merge是一样的，合并前后所处的分支并没有改变。git rebase dev，通俗的解释就是new分支想站在dev的肩膀上继续下去。rebase也需要手动解决冲突。现在我们有这样的两个分支,test和master，提交如下： D—E test /A—B—C—F master 在master执行git merge test,然后会得到如下结果： D——–E / \\A—B—C—F—-G test, master 在master执行git rebase test，然后得到如下结果： A—B—D—E—C’—F’ test, master 可以看到，merge操作会生成一个新的节点，之前的提交分开显示。而rebase操作不会生成新的节点，是将两个分支融合成一个线性的提交。 如果你想要一个干净的，没有merge commit的线性历史树，那么你应该选择git rebase如果你想保留完整的历史记录，并且想要避免重写commit history的风险，你应该选择使用git merge resetreset命令把当前分支指向另一个位置，并且相应的变动工作区和暂存区。 git reset —soft [commit] 只改变提交点，暂存区和工作目录的内容都不改变git reset —mixed [commit] 改变提交点，同时改变暂存区的内容git reset —hard [commit] 暂存区、工作区的内容都会被修改到与提交点完全一致的状态git reset –hard HEAD 让工作区回到上次提交时的状态 revertgit revert用一个新提交来消除一个历史提交所做的任何修改。 revert与reset的区别 git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit。 在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，减少冲突。但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入，产生很多冲突。关于这一点，不太理解的可以看这篇文章。 git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。 push上传本地仓库分支到远程仓库分支，实现同步。 git push [remote][branch] 上传本地指定分支到远程仓库git push [remote] –force 强行推送当前分支到远程仓库，即使有冲突git push [remote] –all 推送所有分支到远程仓库 其他命令 git status 显示有变更的文件git log 显示当前分支的版本历史git diff 显示暂存区和工作区的差异git diff HEAD 显示工作区与当前分支最新commit之间的差异git cherry-pick [commit] 选择一个commit，合并进当前分支 以上就是关于Git的一些常用命令及详细阐述，相信能对Git有一个初步的认识。","pubDate":"Thu, 24 Aug 2017 06:31:21 GMT","guid":"http://myqilixiang.github.io/2017/08/24/git使用总结/","category":"-git"},{"title":"了解mvvm数据双向绑定","link":"http://myqilixiang.github.io/2017/08/22/了解mvvm数据双向绑定/","description":"先来看看最终实现效果： 1234567891011121314151617181920212223&lt;div id=\"mvvm-app\"&gt; &lt;input type=\"text\" v-model=\"word\"&gt; &lt;p&gt;&#123;&#123;word&#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"sayHi\"&gt;change model&lt;/button&gt;&lt;/div&gt;&lt;script src=\"./js/observer.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/watcher.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/compile.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/mvvm.js\"&gt;&lt;/script&gt;&lt;script&gt;var vm = new MVVM(&#123; el: '#mvvm-app', data: &#123; word: 'Hello World!' &#125;, methods: &#123; sayHi: function() &#123; this.word = 'Hi, everybody!'; &#125; &#125; &#125;);&lt;/script&gt; 实现数据双向绑定的几种方法目前几种主流的mvc(vm)框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。实现数据绑定的做法有大致如下几种： 发布者-订阅者模式（backbone.js）脏值检查（angular.js）数据劫持（vue.js） 发布者-订阅者模式:一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set(‘property’, value)这种方式现在毕竟太low了，我们更希望通过vm.property = value这种方式更新数据，同时自动更新视图，于是有了下面两种方式脏值检查: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下： DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply() 数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 ## 思路整理已经了解到vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一，如果不熟悉defineProperty，猛戳这里整理了一下，要实现mvvm的双向绑定，就必须要实现以下几点：1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图4、mvvm入口函数，整合以上三者绘制流程图如下： 1、实现Observerok, 思路已经整理完毕，也已经比较明确相关逻辑和模块功能了，let’s do it 我们知道可以利用Obeject.defineProperty()来监听属性变动 那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。。相关代码可以是这样： 12345678910111213141516171819202122232425262728var data = &#123;name: 'kindeng'&#125;;observe(data);data.name = 'dmq'; // 哈哈哈，监听到值变化了 kindeng --&gt; dmqfunction observe(data) &#123; if (!data || typeof data !== 'object') &#123; return; &#125; // 取出所有属性遍历 Object.keys(data).forEach(function(key) &#123; defineReactive(data, key, data[key]); &#125;);&#125;;function defineReactive(data, key, val) &#123; observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() &#123; return val; &#125;, set: function(newVal) &#123; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; &#125; &#125;);&#125; 这样我们已经可以监听每个数据的变化了，那么监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法，代码改善之后是这样： 1234567891011121314151617181920212223242526272829// ... 省略function defineReactive(data, key, val) &#123; var dep = new Dep(); observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; // ... 省略 set: function(newVal) &#123; if (val === newVal) return; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; dep.notify(); // 通知所有订阅者 &#125; &#125;);&#125;function Dep() &#123; this.subs = [];&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub); &#125;, notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); &#125;); &#125;&#125;; 那么问题来了，谁是订阅者？怎么往订阅器添加订阅者？ 没错，上面的思路整理中我们已经明确订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作，所以我们可以在getter里面动手脚： 12345678910111213141516171819// Observer.js// ...省略Object.defineProperty(data, key, &#123; get: function() &#123; // 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target &amp;&amp; dep.addDep(Dep.target); return val; &#125; // ... 省略&#125;);// Watcher.jsWatcher.prototype = &#123; get: function(key) &#123; Dep.target = this; this.value = data[key]; // 这里会触发属性的getter，从而添加订阅者 Dep.target = null; &#125;&#125; 这里已经实现了一个Observer了，已经具备了监听数据和数据变化通知订阅者的功能，完整代码。那么接下来就是实现Compile了 2、实现Compilecompile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，如图所示：因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中 12345678910111213141516171819function Compile(el) &#123; this.$el = this.isElementNode(el) ? el : document.querySelector(el); if (this.$el) &#123; this.$fragment = this.node2Fragment(this.$el); this.init(); this.$el.appendChild(this.$fragment); &#125;&#125;Compile.prototype = &#123; init: function() &#123; this.compileElement(this.$fragment); &#125;, node2Fragment: function(el) &#123; var fragment = document.createDocumentFragment(), child; // 将原生节点拷贝到fragment while (child = el.firstChild) &#123; fragment.appendChild(child); &#125; return fragment; &#125;&#125;; compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定，详看代码及注释说明： 123456789101112131415161718192021Compile.prototype = &#123; // ... 省略 compileElement: function(el) &#123; var childNodes = el.childNodes, me = this; [].slice.call(childNodes).forEach(function(node) &#123; var text = node.textContent; var reg = /\\&#123;\\&#123;(.*)\\&#125;\\&#125;/; // 表达式文本 // 按元素节点方式编译 if (me.isElementNode(node)) &#123; me.compile(node); &#125; else if (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123; me.compileText(node, RegExp.$1); &#125; // 遍历编译子节点 if (node.childNodes &amp;&amp; node.childNodes.length) &#123; me.compileElement(node); &#125; &#125;); &#125; // ...省略&#125;; 这里通过递归遍历保证了每个节点及子节点都会解析编译到，包括了{{}}表达式声明的文本节点。指令的声明规定是通过特定前缀的节点属性来标记，如&lt;span v-text=&quot;content&quot; other-attr中v-text便是指令，而other-attr不是指令，只是普通的属性。 监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知至此，一个简单的Compile就完成了，完整代码。接下来要看看Watcher这个订阅者的具体实现了 3、实现WatcherWatcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是:1、在自身实例化时往属性订阅器(dep)里面添加自己2、自身必须有一个update()方法3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 如果有点乱，可以回顾下前面的思路整理 123456789101112131415161718192021222324252627282930313233343536373839404142function Watcher(vm, exp, cb) &#123; this.cb = cb; this.vm = vm; this.exp = exp; // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解 this.value = this.get();&#125;Watcher.prototype = &#123; update: function() &#123; this.run(); // 属性值变化收到通知 &#125;, run: function() &#123; var value = this.get(); // 取到最新值 var oldVal = this.value; if (value !== oldVal) &#123; this.value = value; this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图 &#125; &#125;, get: function() &#123; Dep.target = this; // 将当前订阅者指向自己 var value = this.vm[exp]; // 触发getter，添加自己到属性订阅器中 Dep.target = null; // 添加完毕，重置 return value; &#125;&#125;;// 这里再次列出Observer和Dep，方便理解Object.defineProperty(data, key, &#123; get: function() &#123; // 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target &amp;&amp; dep.addDep(Dep.target); return val; &#125; // ... 省略&#125;);Dep.prototype = &#123; notify: function() &#123; this.subs.forEach(function(sub) &#123; sub.update(); // 调用订阅者的update方法，通知变化 &#125;); &#125;&#125;; 实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。 ok, Watcher也已经实现了，完整代码。 基本上vue中数据绑定相关比较核心的几个模块也是这几个，猛戳这里 , 在src目录可找到vue源码。 最后来讲讲MVVM入口文件的相关逻辑和实现吧，相对就比较简单了~ 4、实现MVVMMVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。一个简单的MVVM构造器是这样子： 123456function MVVM(options) &#123; this.$options = options; var data = this._data = this.$options.data; observe(data, this); this.$compile = new Compile(options.el || document.body, this)&#125; 但是这里有个问题，从代码中可看出监听的数据对象是options.data，每次需要更新视图，则必须通过var vm = new MVVM({data:{name: &#39;kindeng&#39;}}); vm._data.name = &#39;dmq&#39;;这样的方式来改变数据。显然不符合我们一开始的期望，我们所期望的调用方式应该是这样的： var vm = new MVVM({data: {name: &#39;kindeng&#39;}}); vm.name = &#39;dmq&#39;;所以这里需要给MVVM实例添加一个属性代理的方法，使访问vm的属性代理为访问vm._data的属性，改造后的代码如下： 1234567891011121314151617181920212223242526function MVVM(options) &#123; this.$options = options; var data = this._data = this.$options.data, me = this; // 属性代理，实现 vm.xxx -&gt; vm._data.xxx Object.keys(data).forEach(function(key) &#123; me._proxy(key); &#125;); observe(data, this); this.$compile = new Compile(options.el || document.body, this)&#125;MVVM.prototype = &#123; _proxy: function(key) &#123; var me = this; Object.defineProperty(me, key, &#123; configurable: false, enumerable: true, get: function proxyGetter() &#123; return me._data[key]; &#125;, set: function proxySetter(newVal) &#123; me._data[key] = newVal; &#125; &#125;); &#125;&#125;; 这里主要还是利用了Object.defineProperty()这个方法来劫持了vm实例对象的属性的读写权，使读写vm实例的属性转成读写了vm._data的属性值，达到鱼目混珠的效果至此，全部模块和功能已经完成了，如本文开头所承诺的两点。一个简单的MVVM模块已经实现，其思想和原理大部分来自经过简化改造的vue源码，猛戳这里可以看到本文的所有相关代码。 由于本文内容偏实践，所以代码量较多，且不宜列出大篇幅代码，所以建议想深入了解的童鞋可以再次结合本文源代码来进行阅读，这样会更加容易理解和掌握。 总结本文主要围绕“几种实现双向绑定的做法”、“实现Observer”、“实现Compile”、“实现Watcher”、“实现MVVM”这几个模块来阐述了双向绑定的原理和实现。并根据思路流程渐进梳理讲解了一些细节思路和比较关键的内容点，以及通过展示部分关键代码讲述了怎样一步步实现一个双向绑定MVVM。相关文章继续学习","pubDate":"Tue, 22 Aug 2017 01:17:04 GMT","guid":"http://myqilixiang.github.io/2017/08/22/了解mvvm数据双向绑定/","category":"mvvm"},{"title":"vue组件封装及npm包发布","link":"http://myqilixiang.github.io/2017/08/21/vue组件封装及npm包发布/","description":"vue组件封装vue2是基于web components标准的前端框架，它支持用户自定义组件，构建vue项目的过程中我们无处不在使用自定义组件，需要引入第三方组件库则需npm install,下面就简单介绍一下如何将自己自定义的组件按照vue制定的组件封装方式封装并发布到npm，这样便实现了自定义组件第三方化。1、首先建一个自定义组件的文件夹，比如叫loading，里面有一个index.js，还有一个自定义组件loading.vue,在这个loading.vue里面就是这个组件的具体的内容，比如： 12345678910111213141516171819&lt;template&gt; &lt;div&gt; loading.............. &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt;&lt;style scoped&gt; div&#123; font-size:40px; color:#f60; text-align:center; &#125;&lt;/style&gt; 2、在index.js中，规定使用这个组件的名字，以及使用方法，如： 123456789import loadingComponent from './loading.vue'const loading=&#123; install:function(Vue)&#123; Vue.component('Loading',loadingComponent) &#125; //'Loading'这就是后面可以使用的组件的名字，install是默认的一个方法&#125;;export default loading; 3、经过1、2两个步骤就已经完成了组件的封装，只要在index.js中规定了install方法，就可以像一些公共的插件一样使用Vue.use()来使用，如：： 123import loading from './loading'Vue.use(loading) 这是在入口文件中引入的方法，可以看到就像vue-resource一样，可以在项目中的任何地方使用自定义的组件了，比如在home.vue中使用 12345&lt;template&gt; &lt;div&gt; &lt;Loading&gt;&lt;/Loading&gt; &lt;/div&gt;&lt;/template&gt; npm包发布准备工具 安装nodeJS 注册一个github账户用于托管代码 注册一个npm账户 开发你的module，更新至github 发布module至npm安装nodeJS已经github账户的使用在此不做介绍，需要将自己准备发布的代码托管到github上，然后你需要注册一个npm账户，接下来说明发布过程：终端进入到项目文件夹，执行npm init命令，构建模块的描述文件，系统会提示你输入所需的信息，不想输入就直接Enter跳过。这里主要的几个配置如下: name就是你要发布的module名； version版本信息（每发布一次版本号都必须大于上一次发布的版本号）； entry入口文件 123456789101112131415161718192021$ npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sane defaults.See `npm help json` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt; --save` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.name: (node) easy_mongoversion: (0.0.0) 0.1.0description: An easy mongodb client for node.js based on native mongodb driver.entry point: (index.js)test command: testgit repository: https://github.com/Myqilixiang/zsh-koa-cli.gitkeywords: koa2author: zshlicense: (BSD-2-Clause) MIT npm注册输入完用户名，密码，邮箱后没有错误信息就完成了。 1234$ npm adduserUsername: your namePassword: your passwordEmail: (this IS public) your email 查询或者登陆别的用户命令 12npm whoaminpm login npm module 发布module开发完毕后，剩下的就是发布啦，进入项目根目录，输入命令。 1npm publish 这里有时候会遇到几个问题,问题1： 1npm ERR! no_perms Private mode enable, only admin can publish this module: 这里注意的是因为国内网络问题，许多小伙伴把npm的镜像代理到淘宝或者别的地方了，这里要设置回原来的镜像。 1npm config set registry=http://registry.npmjs.org 问题2： 1npm ERR! you do not have permission to publish \"your module name\". Are you logged in as the correct user? 提示没有权限，其实就是你的module名在npm上已经被占用啦，这时候你就去需要去npm搜索你的模块名称，如果搜索不到，就可以用，并且把package.json里的name修改过来，重新npm publish，看到如下信息就表示安装完成了，zsh-koa-cli就是我的模块名。 zsh-koa-cli@0.1.0更新版本，发布 12npm version 0.1.1npm publish 版本号规范npm社区版本号规则采用的是semver（语义化版本），主要规则版本格式：主版本号.次版本号.修订号，版本号递增规则如下： 主版本号：当你做了不兼容的 API 修改， 次版本号：当你做了向下兼容的功能性新增， 修订号：当你做了向下兼容的问题修正。先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。 持续集成目前npm上开源的项目实在是太多，从中找出靠谱的项目要花费一定的精力跟时间去验证，所以开发者都会对自己的开源项目持续更新，并且经过测试的项目更加值得信赖。对于刚上线并且github上star星数很少的项目，使用者都会怀疑，这个项目靠谱不？所以这时候你需要告诉他，老子靠谱，怎么做？持续集成。 目前Github已经整合了持续集成服务travis，我们只需要在项目中添加.travis.yml文件，在下一次push之后，travis就会定时执行npm test来测试你的项目，并且会在测试失败的时候通知到你，你也可以把项目当前的状态显示在README.md中，让人一目了然，比如React里的.travis.yml 是一个YAML文件，具体的相关的配置见This，例子如下： 1234567language: node_jsnode_js: - \"6\" - \"6.1\" - \"5.11\"services: - mongodb 这个例子的是让travis在node.js的0.6.x，0.6.1，0.5.11三个版本下对项目进行测试，并且需要mongodb的服务。 End 至此你的一个module就开发完成了。","pubDate":"Mon, 21 Aug 2017 01:36:39 GMT","guid":"http://myqilixiang.github.io/2017/08/21/vue组件封装及npm包发布/","category":"vue组件封装,npm发布"},{"title":"自定义脚手架","link":"http://myqilixiang.github.io/2017/08/18/自定义脚手架/","description":"前言在实际的开发过程中，从零开始建立项目的结构是一件让人头疼的事情，所以各种各样的脚手架工具应运而生。笔者使用较多的yoeman，express-generator和vue-cli便是当中之一。它们功能丰富，但最核心的功能都是能够快速搭建一个完整的项目的结构，开发者只需要在生成的项目结构的基础上进行开发即可，非常简单高效。之前已经上传了koa-boilerplate项目，是一个koa2的模板，此次将其构建为脚手架，并发布。 核心原理脚手架功能其实就是将模板文件拷贝到本地，模板可以内置在脚手架中，也可以部署在远程仓库。 技术选型 node.js：整个脚手架工具的根本组成部分，推荐使用最新的版本。 es6：新版本的node.js对于es6的支持度已经非常高，使用es6能够极大地提升开发效率和开发感受。 commander：TJ大神开发的工具，能够更好地组织和处理命令行的输入。 co：TJ大神开发的异步流程控制工具，用更舒服的方式写异步代码。 co-prompt：还是TJ大神的作品……传统的命令行只能单行一次性地输入所有参数和选项，使用这个工具可以自动提供提示信息，并且分步接收用户的输入，体验类似npm init时的一步一步输入参数的过程。 整体架构架构图如下：首先明白模版的概念。一个模版就是一个项目的样板，包含项目的完整结构和信息。模版的信息都存放在一个叫做templates.json的文件当中。用户可以通过命令行对templates.json进行添加、删除、罗列的操作。通过选择不同的模版，koa-init会自动从远程仓库把相应的模板拉取到本地，完成项目的搭建。最终整个脚手架的文件结构如下： 1234567891011================= |__ bin |__ koa |__ command |__ add.js |__ delete.js |__ init.js |__ list.js |__ node_modules |__ package.json |__ templates.json 入口文件首先建立项目，在package.json里面写入依赖并执行npm install： 123456\"dependencies\": &#123; \"chalk\": \"^1.1.3\", \"co\": \"^4.6.0\", \"co-prompt\": \"^1.0.0\", \"commander\": \"^2.9.0\" &#125; 在根目录下建立\\bin文件夹，在里面建立一个无后缀名的koa文件。这个bin\\koa文件是整个脚手架的入口文件，所以我们首先对它进行编写。 首先是一些初始化的代码： 1234567891011121314 #!/usr/bin/env node --harmony'use strict' // 定义脚手架的文件路径process.env.NODE_PATH = __dirname + '/../node_modules/'const program = require('commander') // 定义当前版本program .version(require('../package').version )// 定义使用方法program .usage('&lt;command&gt;') 从前文的架构图中可以知道，脚手架支持用户输入4种不同的命令。现在我们来写处理这4种命令的方法： 12345678910111213141516171819202122232425262728293031program .command('add') .description('Add a new template') .alias('a') .action(() =&gt; &#123; require('../command/add')() &#125;)program .command('list') .description('List all the templates') .alias('l') .action(() =&gt; &#123; require('../command/list')() &#125;)program .command('init') .description('Generate a new project') .alias('i') .action(() =&gt; &#123; require('../command/init')() &#125;)program .command('delete') .description('Delete a template') .alias('d') .action(() =&gt; &#123; require('../command/delete')() &#125;) commander的具体使用方法在这里就不展开了，可以直接到官网去看详细的文档。最后别忘了处理参数和提供帮助信息： 12345program.parse(process.argv)if(!program.args.length)&#123; program.help()&#125; 完整的代码请看这里。使用node运行这个文件，看到输出如下，证明入口文件已经编写完成了。 1234567891011121314Usage: koa-init &lt;command&gt; Commands: add|a Add a new template list|l List all the templates init|i Generate a new project delete|d Delete a template Options: -h, --help output usage information -V, --version output the version number 处理用户输入在项目根目录下建立\\command文件夹，专门用来存放命令处理文件。在根目录下建立templates.json文件并写入如下内容，用来存放模版信息： 1&#123;\"tpl\":&#123;&#125;&#125; 添加模板进入\\command并新建add.js文件： 123456789101112131415161718192021222324252627282930313233343536'use strict'const co = require('co')const prompt = require('co-prompt')const config = require('../templates')const chalk = require('chalk')const fs = require('fs')module.exports = () =&gt; &#123; co(function *() &#123; // 分步接收用户输入的参数 let tplName = yield prompt('Template name: ') let gitUrl = yield prompt('Git https link: ') let branch = yield prompt('Branch: ') // 避免重复添加 if (!config.tpl[tplName]) &#123; config.tpl[tplName] = &#123;&#125; config.tpl[tplName]['url'] = gitUrl.replace(/[\\u0000-\\u0019]/g, '') // 过滤unicode字符 config.tpl[tplName]['branch'] = branch &#125; else &#123; console.log(chalk.red('Template has already existed!')) process.exit() &#125; // 把模板信息写入templates.json fs.writeFile(__dirname + '/../templates.json', JSON.stringify(config), 'utf-8', (err) =&gt; &#123; if (err) console.log(err) console.log(chalk.green('New template added!\\n')) console.log(chalk.grey('The last template list is: \\n')) console.log(config) console.log('\\n') process.exit() &#125;) &#125;)&#125; 删除模板同样的，在\\command文件夹下建立delete.js文件： 12345678910111213141516171819202122232425262728293031'use strict'const co = require('co')const prompt = require('co-prompt')const config = require('../templates')const chalk = require('chalk')const fs = require('fs')module.exports = () =&gt; &#123; co(function *() &#123; // 接收用户输入的参数 let tplName = yield prompt('Template name: ') // 删除对应的模板 if (config.tpl[tplName]) &#123; config.tpl[tplName] = undefined &#125; else &#123; console.log(chalk.red('Template does not exist!')) process.exit() &#125; // 写入template.json fs.writeFile(__dirname + '/../templates.json', JSON.stringify(config), 'utf-8', (err) =&gt; &#123; if (err) console.log(err) console.log(chalk.green('Template deleted!')) console.log(chalk.grey('The last template list is: \\n')) console.log(config) console.log('\\n') process.exit() &#125;) &#125;)&#125; 罗列模板建立list.js文件： 1234567'use strict'const config = require('../templates')module.exports = () =&gt; &#123; console.log(config.tpl) process.exit()&#125; 构建项目现在来到我们最重要的部分——构建项目。同样的，在\\command目录下新建一个叫做init.js的文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const &#123; prompt &#125; = require('inquirer')const &#123; writeFile &#125; = require('fs')const &#123; listTable &#125; = require(`$&#123;__dirname&#125;/../utils`)const &#123; resolve &#125; = require('path')const chalk = require('chalk')const download = require('download-git-repo')const ora = require('ora')let tplList = require(`$&#123;__dirname&#125;/../templates`)const question = [ &#123; type: 'input', name: 'name', message: 'Template name:', validate (val) &#123; if (tplList[val]) &#123; return true &#125; else if (val === '') &#123; return 'Name is required!' &#125; else if (!tplList[val]) &#123; return 'This template doesn\\'t exists.' &#125; &#125; &#125;, &#123; type: 'input', name: 'project', message: 'Project name:', validate (val) &#123; if (val !== '') &#123; return true &#125; return 'Project name is required!' &#125; &#125;, &#123; type: 'input', name: 'place', message: 'Where to init the project:', default: './' &#125;]module.exports = prompt(question).then((&#123; name, project, place &#125;) =&gt; &#123; const gitPlace = tplList[name]['owner/name'] const gitBranch = tplList[name]['branch'] const spinner = ora('Downloading template...') spinner.start() download(`$&#123;gitPlace&#125;#$&#123;gitBranch&#125;`, `$&#123;place&#125;/$&#123;project&#125;`, (err) =&gt; &#123; if (err) &#123; console.log(chalk.red(err)) process.exit() &#125; spinner.stop() console.log(chalk.green('New project has been initialized successfully!')) &#125;)&#125;) 这里使用了download-git-repo用于从远程仓库克隆到自定义目录。 全局使用为了可以全局使用，我们需要在package.json里面设置一下： 123\"bin\": &#123; \"koa-init\": \"bin/koa\" &#125;, 本地调试的时候，在根目录下执行 1npm link 即可把koa-cli命令绑定到全局，以后就可以直接以koa-init作为命令开头而无需敲入长长的node koa之类的命令了。 部署 将完成的项目部署在git上 发布脚手架 参考npm包发布发布脚手架 测试使用 发布成功后，运行下列命令安装 1npm install zsh-koa --save 构建工程 1zsh-koa init 按照提示输入工程名和下载位置 End","pubDate":"Fri, 18 Aug 2017 07:57:41 GMT","guid":"http://myqilixiang.github.io/2017/08/18/自定义脚手架/","category":"commander,init - cli"},{"title":"GraphQL vs REST","link":"http://myqilixiang.github.io/2017/08/16/REST-GraphQL/","description":"GraphQL是什么GraphQL 是一门语言。 如果我们传授 GraphQL 语言给一款应用，这款应用就能够向支持 GraphQL 的后端数据服务声明式传达数据需求。为了让数据服务支持 GraphQL，我们需要实现一个运行时层并将它暴露给想要与服务通信的客户端。可以将这个添加到服务端的层简单地看作是一位 GraphQL 语言翻译员，或代表数据服务并会说 GraphQL 语言的代理。GraphQL 并不是一个存储引擎，所以它不能作为一个独立的解决方案。这就是我们不能有一个纯粹的 GraphQL 服务，而需要实现一个翻译运行时的原因。 这个层可以用任何语言编写，它定义了一个通用的基于图的模板来发布它所代表的数据服务的功能。支持 GraphQL 的客户端可以在功能允许的范围内使用这种模版进行查询。这一策略可以将客户端与服务端分离，允许两者独立开发和扩展。 一个 GraphQL 请求既可以是查询（读操作），也可以是修改（写操作）。不管是何种情形，请求均只是一个带有特定格式的简单字符串，GraphQL 服务器可以对其进行解析、执行、处理。在移动和 Web 应用中最常见的响应格式是 JSON 。 REST API 有什么错REST API 最大的问题是其天然倾向多端点。这造成客户端需要多次往返获取数据。 REST API 通常由多个端点组成，每个端点代表一种资源。因此，当客户端需要多个资源时，它需要向 REST API 发起多个请求，才能获取到所需要的数据。 在 REST API 中，是没有描述客户端请求的语言的。客户端无法控制服务器返回哪些数据。没有让客户端对返回数据进行控制的语言。更确切的说，客户端能使用的语言是很有限的。例如，有如下进行读取操作的 REST API： GET /ResouceName - 从该资源获取包含所有记录的列表 GET /ResourceName/ResourceID - 通过 ID 获取某条特定记录 例如，客户端是不能够指定从该资源的记录中选择哪些字段的。信息仅存在于提供 REST API 的服务中，该服务将始终返回所有字段，而不管客户端需要什么。借用 GraphQL 术语描述这个问题：超额获取(over-fetching) 没用的信息。这浪费了服务器和客户端的网络内存资源 REST API 的另一个大问题就是版本控制了。如果你需要支持多版本，那你就需要为此创建多个新的端点。这会导致这些端点很难使用和维护，此外，还造成服务端出现很多冗余代码。 上面列出的一些 REST API 带来的问题都是 GraphQL 试图解决的。这并不是 REST API 带来的全部问题，我也不打算说明 REST API 是什么不是什么。我只是在谈论一种最流行的基于资源的 HTTP 终点 API。这些 API 最终都会变成一种具有常规 REST 特性的端点和出于性能原因定制的特殊端点的组合。 GraphQL 如何实现其魔力在 GraphQL 背后有很多的概念和设计策略，这儿列举了一些最重要的： GraphQL 模板是强类型的。要创建一套 GraphQL 模板，我们需要定义了一些带有类型的字段。这些类型可以是原始数据类型也可以是自定义的，在模板中一切均需要类型。丰富的类型系统带来了丰富的特性，如 API 自证，这让我们能够为客户端和服务端创建强大的工具。 GraphQL 以图的形式组织数据，数据自然形成图。如果你需要一个结构描述数据，图是一种不错的选择。GraphQL 运行时让我们能够使用与该数据的自然图结构匹配的图 API 来表示我们的数据。 GraphQL 具有表达数据需求声明性质。GraphQL 让客户端能够以一种声明性的语言描述其对数据的需求。这种声明性带来了一种围绕着 GraphQL 语言使用的心智模型，该模型与我们用自然语言思考数据需求的方式接近，让我们使用 GraphQL 时比使用其它方式更容易。最后一个概念是我为什么认为 GraphQL 是游戏规则改变者的原因。 这些全是抽象概念。让我们深入到细节中。 为了解决多次往返请求的问题，GraphQL 让响应服务器变成一个端点。本质上，GraphQL 把自定义端点这一思想发挥到了极致，它让这个端点能够回复所有数据问题。 伴随着单个端点这一概念的另一个重要概念是需要一种强大的客户端请求描述语言与自定义的单个端点进行通信。缺少客户端请求描述语言，单个端点是没有意义的。它需要一种语言解析自定义请求以及根据自定义请求返回数据。 拥有一门客户端请求描述语言意味这客户端能够对请求进行控制。客户端能够精确表达它们需要什么，服务端也能精准回复客户端需要的。这就解决了超额获取的问题。 当涉及到版本时，GraphQL 提供了一种有趣的解决方式。版本能够被完全避免。基本上，我们只需要在保留老的字段的基础上添加新字段即可，因为我们用的是图，我们能很灵活的在图上添加更多节点。因此，我们可以在图上留下旧的 API，并引入新的 API，而不会将其标记为新版本。API 只是多了更多节点。 这点对于移动端尤为重用，因为我们无法充值这些移动端使用的版本。一经安装，移动端应用可能数年都使用老版本 API 。对于 Web，我们可以通过发布新代码简单的控制 API 版本，对于移动端应用，这点很难做到。 还没有完全相信？ 结合实例一对一对比 GraphQL 和 REST 怎么样？ REST 风格 API vs GraphQL API —— 案例我们假设我们是开发者，负责构建闪亮全新的用户界面，用来展示星球大战影片和角色。 我们要构建的第一份 UI 很简单：一个显示单个星球大战角色的信息视图。例如，达斯·维德以及电影中出场的其他角色。这个视图需要显示角色的姓名、出生年份、母星名、以及出场的所有影片中出现的头衔。 听起来很简单，我们实际上已经需要处理三种不同的资源：人物、星球和电影。资源之间的关系很简单，任何人都很容易就猜出这里的数据组成。 此 UI 的 JSON 数据可能类似于： 1234567891011121314151617&#123; \"data\": &#123; \"person\": &#123; \"name\": \"Darth Vader\", \"birthYear\": \"41.9BBY\", \"planet\": &#123; \"name\": \"Tatooine\" &#125;, \"films\": [ &#123; \"title\": \"A New Hope\" &#125;, &#123; \"title\": \"The Empire Strikes Back\" &#125;, &#123; \"title\": \"Return of the Jedi\" &#125;, &#123; \"title\": \"Revenge of the Sith\" &#125; ] &#125; &#125;&#125; 假设数据服务按照上面的结构返回数据给我们。我们有一种可行的方式即使用 React.js 来展现视图： 12345678// The Container Component:&lt;PersonProfile person=&#123;data.person&#125; &gt;&lt;/PersonProfile&gt;// The PersonProfile Component:Name: &#123;person.name&#125;Birth Year: &#123;person.birthYear&#125;Planet: &#123;person.planet.name&#125;Films: &#123;person.films.map(film =&gt; film.title)&#125; 这是一个简单例子，此外我们关于星球大战的经验也能帮我们一点忙，我们可以很清楚的明白 UI 和数据之间的关系。与我们想象一致，UI 是使用了 JSON 数据对象中的全部的键。 让我们来看看如何通过 REST 风格 API 获取这些数据。 我们需要单个角色的信息，假设我们知道这个角色的 ID，REST 风格的 API 倾向于这样输出这些信息： 1GET - /people/&#123;id&#125; 这个请求将会返回角色的姓名、出生年份以及一些其它信息给我们。一个规范的 REST 风格 API 将会返回给我们角色星球的 ID 以及该角色出现过的所有影片的 ID 组成的数组。 这个请求以 JSON 格式返回的响应类似于： 1234567&#123; \"name\": \"Darth Vader\", \"birthYear\": \"41.9BBY\", \"planetId\": 1 \"filmIds\": [1, 2, 3, 6], *** 其它信息我们不需要 ***&#125; 然后为了获取星球名称，我们发起请求： 1GET - /planets/1 接着为了获取影片中的头衔，我们发起请求： 1234GET - /films/1GET - /films/2GET - /films/3GET - /films/6 当从服务器接受到所有的六个数据后，我们才能将其组合并生成满足视图需要的数据。 除了有需要六次往返才能获取到满足一个简单 UI 需求的数据这一事实外，这种方式并无不可。我们阐明了如何获取数据，以及如何处理数据使其满足视图需要。 如果你想确认我说的你可以自己动手尝试。有一个部署在 swapi.co/ 上的 REST API 服务提供了星球大战的数据，点进去，在里面尝试构造角色数据。数据的键名可能不同，但 API 端点是一致的。你同样需要进行六次 API 调用。同样，你不得不超额获取视图不需要的信息。 当然，这只是 REST API 的一个实现方式，可能有更好的实现让生成视图更简单。例如，如果 API 服务支持资源嵌套并能理解角色和影片之间的关系，我们能够通过这种方式获取影片数据： 1GET - /people/&#123;id&#125;/films 然而，一个纯粹的 REST API 服务很难实现这点。我们需要让后端工程师为我们创建自定义端点。这造成 REST API 规模不断增长这一事实 —— 为了满足不断增长的客户端的需要，我们不断添加自定义端点。管理这些自定义端点很难。 让我们来看一看 GraphQL 策略。GraphQL 在服务端拥抱自定义端点思想并把它发展到极致。服务将只是一个端点，通道变得没有意义。如果我们使用 HTTP 实现，HTTP 方法将失去意义。假设我们有一个单一的 GraphQL 端点，它的 HTTP 地址是 /graphql 因为我们希望一次往返获取需要的数据，所以我们需要明明白白告诉服务器我们需要哪些数据。我们通过 GraphQL 进行查询： 1GET or POST - /graphql?query=&#123;...&#125; GraphQL 查询只是字符串，但它将包含我们需要的全部数据。这就是声明的强大之处。 英语中，我们这样阐述数据需求：我们需要角色名、出生年份、星球名和在所有出现过的影片中的头衔。通过 GraphQL，我们进行如下转换： 123456789101112&#123; person(ID: ...) &#123; name, birthYear, planet &#123; name &#125;, films &#123; title &#125; &#125;&#125; 再细读一次英语表述的需求并与 GraphQL 查询进行对比。它们不能再更接近了。现在，将 GraphQL 查询与我们最开始用到的原始 JSON 数据进行对比。GraphQL 查询完全与 JSON 数据结构相对应，不过排除所有是值的部分。如果我们仿照问题与答案关系来考虑这中情况，那问题就是没有具体答案的答案原语。如果答案是： 离太阳最近的星球是水星。一种好的提问方式是保留原话只去掉提问部分：哪个星球里太阳最近？这种关系同样适用于 GraphQL 查询。拿着 JSON 格式的响应数据，移除所有是答案的部分（作为值的对象），最后你得到了一个非常适合代表关于 JSON 响应问题的 GraphQL 查询。现在，将 GraphQL 查询和与我们展示数据的声明性 React UI 对比。所有出现在 GraphQL 查询中的数据都出现在了 UI 中。所有出现在 UI 中的数据都出现在了 GraphQL 查询中。 这就是 GraphQL 强大的心智模型。UI 知晓它所需要的确切数据，提取需要的数据也很容易。编写 GraphQL 查询变成一个从 UI 中提取作为变量这一简单的工作。 将模型进行反转，它仍然很强大。如果我们知道了 GraphQL 查询，我们同样知道如何在 UI 中使用相应数据。我们不需要分析响应数据就能使用它，也不需要的这些 API 的文档。这一切都是内建的。 获取星球大战数据的 GraphQL 托管在 github.com/graphql/swa…。点击进去并尝试构造角色数据。只有一点点不同，我们之后会谈论，以下是可以从这个 API 中获取视图所需要数据的正式查询（使用达斯·维德举例） 1234567891011121314&#123; person(personID: 4) &#123; name, birthYear, homeworld &#123; name &#125;, filmConnection &#123; films &#123; title &#125; &#125; &#125;&#125; 这个请求返回的我们的响应数据结构十分接近视图用到的，记住，这些数据是我们通过一次往返获得的。 GraphQL 灵活性带来的开销完美的解决方案是不存在的。GraphQL 带来了灵活性，也带来了一些明确的问题和考量。 GraphQL更容易的造成一个安全隐患是资源耗尽型攻击（拒绝服务攻击）。GraphQL 服务器可能会受到伴随着极其复杂的查询的攻击，造成服务器资源耗尽。很容易就能构造一个深度嵌套关系链（用户 -&gt; 好友 -&gt; 好友的好友。) 或者多次通过字段别名请求同一字段的查询。资源耗尽型攻击并没有限定 GraphQL，但是在使用 GraphQL 时，我们要特别小心。 这儿有一些缓解措施我们可以用上。我们可以进行一些高级查询的开销分析，对单个用户请求的数据量做某种限制。我们也可以实现一种机制对需要很长时间处理的请求进行超时处理。此外，考虑到 GraphQL 就只是一个处理层，我们能在 GraphQL 之下的更底层进行速率限制。 如果我们尝试保护的 GraphQL API 端点并不是公开的，仅供我们私有的客户端（web、移动）内部访问，我们能够使用白名单策略并预先审核服务器能够处理的查询。客户端仅能通过唯一查询标识码向服务器发起审核过的查询。Facebook 似乎就采用了这种策略。 当使用 GraphQL 时，我们还需要考虑到认证和授权。我们是在 GraphQL 解析请求之前，之后还是之间处理它们呢？ 为了回答这个问题，需要将 GraphQL 想象成你一种位于你的后端数据请求逻辑顶层的 DSL（领域限定语言）。它只是一个能够被我们放在客户端与实际数据服务（多个）之间的处理层。 将认证和授权当成另一个处理层。GraphQL 与认证和授权逻辑的具体实现关系不大。它的意义不在这儿。但是如果我们把这些层放在 GraphQL 之后，我们就可以在 GraphQL 层使用访问令牌连通客户端与执行逻辑。这和我们在 REST 风格 API 处理认证和授权类似。 另一件因为 GraphQL 而变得更具挑战性的任务是客户端数据缓存。REST 风格的 API 因其类似目录更容易进行缓存处理。REST API 通过访问路径获取数据，我们能够使用访问路径作缓存键。 对于 GraphQL，我们能够采用类似的策略使用查询字段作为响应数据的缓存键。但是这种方式有限制，效率低下，还容易造成数据一致性方面的问题。原因是多个 GraphQL 查询的结果很容易重叠，而这种缓存策略并没有考虑到这种重叠。 这个问题有一个很好的解决方案。一个图的查询意味这一个图的缓存。如果我们将一个 GraphQL 查询的响应数据正则化为一个平铺的记录集合，为每个记录设置一个全局唯一 ID，我们就能够只缓存这些记录而不用缓存整个响应了。 这种处理并不容易。这样导致一些记录指向另一些记录，导致我们可能得管理一个环形图，导致在写入和读取缓存时我们需要进行遍历，导致我们需要编写一个层来处理缓存逻辑。但是，这种方法总体上比基于响应的缓存更高效。Relay.js 就是一个采用这种缓存策略并在内部进行自动管理的框架。 对于 GraphQL 我们最需要关心的问题可能是被普遍称作 N+1 SQL 查询的问题了。GraphQL 的字段查询被设计成独立的函数，从数据库获取这些字段可能造成每个字段都需要一个数据库查询。 简单 REST 风格 API 端点的逻辑，易分析，易检测，可以优化 SQL 查询语句来解决 N+1 问题。而 GraphQL 需要动态处理字段，这点不容易做到。幸运的是 Facebook 正在研发一个处理类似问题的可能的解决方案：DataLoader。 如名字暗示，DataLoader 是一款能让我们从数据库读取数据并让数据能被 GraphQL 处理函数使用的工具。我们使用 DataLoader，而不是直接通过 SQL 查询从数据库获取数据，将 DataLoader 作为代理以减少我们实际需要发送给数据库的 SQL 查询。 DataLoader 使用批处理和缓存的组合来实现。如果同一个客户端请求会造成多次请求数据库，DataLoader 会整合这些问题并从数据库批量拉取请求数据。DataLoader 会同时缓存这些数据，当有后续请求需要同样资源时可以直接从缓存获取到。","pubDate":"Wed, 16 Aug 2017 02:12:44 GMT","guid":"http://myqilixiang.github.io/2017/08/16/REST-GraphQL/","category":"Graph,REST"}]}